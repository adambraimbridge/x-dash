{"version":3,"file":"main.e811aaaa61694ede2a07.bundle.js","sources":["webpack:///./components/x-interaction/dist/Interaction.es5.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar xEngine = require('@financial-times/x-engine');\nvar shortId = _interopDefault(require('@quarterto/short-id'));\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return _assertThisInitialized(self);\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  }\n}\n\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\n\nvar InteractionRender = function InteractionRender(_ref) {\n  var id = _ref.id,\n      actions = _ref.actions,\n      state = _ref.state,\n      initialState = _ref.initialState,\n      inFlight = _ref.inFlight,\n      Component = _ref.Component;\n  return xEngine.h(Component, Object.assign({}, initialState, state, {\n    id: id,\n    actions: actions\n  }, {\n    isLoading: inFlight > 0\n  }));\n};\n\nvar mapValues = function mapValues(obj, fn) {\n  return Object.keys(obj).reduce(function (mapped, key) {\n    return Object.assign(mapped, _defineProperty({}, key, fn(obj[key], key, obj)));\n  }, {});\n};\n\nvar InteractionClass =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(InteractionClass, _Component);\n\n  function InteractionClass(props) {\n    var _getPrototypeOf2;\n\n    var _this;\n\n    _classCallCheck(this, InteractionClass);\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    _this = _possibleConstructorReturn(this, (_getPrototypeOf2 = _getPrototypeOf(InteractionClass)).call.apply(_getPrototypeOf2, [this, props].concat(args)));\n    _this.state = {\n      state: {},\n      inFlight: 0\n    };\n\n    _this.createActions(props);\n\n    return _this;\n  }\n\n  _createClass(InteractionClass, [{\n    key: \"createActions\",\n    value: function createActions(props) {\n      var _this2 = this;\n\n      this.actions = mapValues(props.actions, function (func) {\n        return function () {\n          var $args = arguments;\n          return new Promise(function ($return, $error) {\n            var stateUpdate, nextState;\n            // mark as loading one microtask later. if the action is synchronous then\n            // setting loading back to false will happen in the same microtask and no\n            // additional render will be scheduled.\n            Promise.resolve().then(function () {\n              _this2.setState(function (_ref) {\n                var inFlight = _ref.inFlight;\n                return {\n                  inFlight: inFlight + 1\n                };\n              });\n            });\n            return Promise.resolve(Promise.resolve(func.apply(void 0, $args))).then(function ($await_3) {\n              try {\n                stateUpdate = $await_3;\n                return Promise.resolve(new Promise(function ($return, $error) {\n                  if (typeof stateUpdate === 'function') {\n                    return Promise.resolve(Promise.resolve(stateUpdate(Object.assign({}, props.initialState, _this2.state.state)))).then(function ($await_4) {\n                      try {\n                        return $return(Object.assign(_this2.state.state, $await_4));\n                      } catch ($boundEx) {\n                        return $error($boundEx);\n                      }\n                    }, $error);\n                  }\n\n                  return $return(Object.assign(_this2.state.state, stateUpdate));\n                })).then(function ($await_5) {\n                  try {\n                    nextState = $await_5;\n                    return $return(new Promise(function (resolve) {\n                      return _this2.setState({\n                        state: nextState\n                      }, function () {\n                        return _this2.setState(function (_ref2) {\n                          var inFlight = _ref2.inFlight;\n                          return {\n                            inFlight: inFlight - 1\n                          };\n                        }, resolve);\n                      });\n                    }));\n                  } catch ($boundEx) {\n                    return $error($boundEx);\n                  }\n                }, $error);\n              } catch ($boundEx) {\n                return $error($boundEx);\n              }\n            }, $error);\n          });\n        };\n      });\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(props) {\n      this.createActions(props);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.actionsRef) {\n        this.props.actionsRef(this.actions);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.actionsRef) {\n        this.props.actionsRef(null);\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return xEngine.h(InteractionRender, Object.assign({}, this.props, this.state, {\n        actions: this.actions\n      }));\n    }\n  }]);\n\n  return InteractionClass;\n}(xEngine.Component);\n\nvar getComponentName = function getComponentName(Component) {\n  return Component.displayName || Component.name || 'Unknown';\n};\n\nvar InteractionSSR = function InteractionSSR(_ref) {\n  var initialState = _ref.initialState,\n      Component = _ref.Component,\n      _ref$id = _ref.id,\n      id = _ref$id === void 0 ? \"\".concat(getComponentName(Component), \"-\").concat(shortId()) : _ref$id,\n      actions = _ref.actions,\n      serialiser = _ref.serialiser;\n\n  if (serialiser) {\n    serialiser.addData({\n      id: id,\n      Component: Component,\n      props: initialState\n    });\n  }\n\n  return xEngine.h(\"div\", {\n    \"data-x-dash-id\": id\n  }, xEngine.h(InteractionRender, {\n    Component: Component,\n    initialState: initialState,\n    id: id,\n    actions: actions\n  }));\n};\n\nfunction wrapComponentName(Component, Enhanced) {\n  var originalDisplayName = getComponentName(Component);\n  Enhanced.displayName = \"withActions(\".concat(originalDisplayName, \")\");\n  Enhanced.wrappedDisplayName = originalDisplayName;\n}\n\nvar registeredComponents = {};\nfunction registerComponent(component) {\n  registeredComponents[component.wrappedDisplayName] = component;\n}\nfunction getComponent(name) {\n  return registeredComponents[name];\n}\n\nvar HydrationWrapper =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(HydrationWrapper, _Component);\n\n  function HydrationWrapper() {\n    _classCallCheck(this, HydrationWrapper);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(HydrationWrapper).apply(this, arguments));\n  }\n\n  _createClass(HydrationWrapper, [{\n    key: \"render\",\n    value: function render() {\n      var _this = this;\n\n      var _this$props = this.props,\n          Component = _this$props.Component,\n          props = _this$props.props,\n          id = _this$props.id;\n      return xEngine.h(Component, Object.assign({}, props, {\n        id: id,\n        actionsRef: function actionsRef(a) {\n          return _this.actions = a;\n        }\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      if (this.props.wrapper) {\n        this.props.wrapper.addEventListener('x-interaction.trigger-action', this);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      if (this.props.wrapper) {\n        this.props.wrapper.removeEventListener('x-interaction.trigger-action', this);\n      }\n    }\n  }, {\n    key: \"handleEvent\",\n    value: function handleEvent(event) {\n      var _event$detail = event.detail,\n          action = _event$detail.action,\n          _event$detail$args = _event$detail.args,\n          args = _event$detail$args === void 0 ? [] : _event$detail$args;\n\n      if (this.actions && this.actions[action]) {\n        var _this$actions;\n\n        (_this$actions = this.actions)[action].apply(_this$actions, _toConsumableArray(args));\n      }\n    }\n  }]);\n\n  return HydrationWrapper;\n}(xEngine.Component);\nfunction hydrate() {\n  if (typeof window === 'undefined') {\n    throw new Error('x-interaction hydrate should only be called in the browser');\n  }\n\n  if (!('_xDashInteractionHydrationData' in window)) {\n    throw new Error(\"x-interaction hydrate was called without hydration data available. this can happen if you call hydrate before the serialised data is available, or if you're not including the hydration data with your server-rendered markup.\");\n  }\n\n  var serialiserOrdering = \"make sure you're always outputting the serialiser's data in the same request that the serialiser was created. see https://financial-times.github.io/x-dash/components/x-interaction/#hydrating for more details.\";\n\n  window._xDashInteractionHydrationData.forEach(function (_ref) {\n    var id = _ref.id,\n        component = _ref.component,\n        props = _ref.props;\n    var wrapper = document.querySelector(\"[data-x-dash-id=\\\"\".concat(id, \"\\\"]\"));\n\n    if (!wrapper) {\n      throw new Error(\"component markup for \".concat(id, \" was not found on the page. It was expected to be an instance of \").concat(component, \". it's likely that this hydration data is from another request. \").concat(serialiserOrdering));\n    }\n\n    var Component = getComponent(component);\n\n    while (wrapper.firstChild) {\n      wrapper.removeChild(wrapper.firstChild);\n    }\n\n    xEngine.render(xEngine.h(HydrationWrapper, {\n      Component: Component,\n      props: props,\n      id: id,\n      wrapper: wrapper\n    }), wrapper);\n  });\n\n  document.querySelectorAll('[data-x-dash-id]').forEach(function (element) {\n    var xDashId = element.dataset.xDashId;\n\n    var hasData = window._xDashInteractionHydrationData.some(function (_ref2) {\n      var id = _ref2.id;\n      return id === xDashId;\n    });\n\n    if (!hasData) {\n      throw new Error(\"found component markup for \".concat(xDashId, \" without any hydration data. it's likely that its hydration data has been output in another request, or that the component was rendered after the serialisation data was output. \").concat(serialiserOrdering));\n    }\n  });\n}\n\nvar HydrationData = function HydrationData(_ref) {\n  var serialiser = _ref.serialiser;\n\n  if (serialiser) {\n    var data = serialiser.flushHydrationData();\n    return xEngine.h(\"script\", {\n      dangerouslySetInnerHTML: {\n        __html: \"window._xDashInteractionHydrationData = \".concat(JSON.stringify(data))\n      }\n    });\n  }\n\n  return null;\n};\n\nvar Serialiser =\n/*#__PURE__*/\nfunction () {\n  function Serialiser() {\n    _classCallCheck(this, Serialiser);\n\n    this.destroyed = false;\n    this.data = [];\n  }\n\n  _createClass(Serialiser, [{\n    key: \"addData\",\n    value: function addData(_ref) {\n      var id = _ref.id,\n          Component = _ref.Component,\n          props = _ref.props;\n\n      if (this.destroyed) {\n        throw new Error(\"an interaction component was rendered after flushHydrationData was called. ensure you're outputting the hydration data after rendering every component\");\n      }\n\n      this.data.push({\n        id: id,\n        component: getComponentName(Component),\n        props: props\n      });\n    }\n  }, {\n    key: \"flushHydrationData\",\n    value: function flushHydrationData() {\n      if (this.destroyed) {\n        throw new Error(\"a Serialiser's flushHydrationData was called twice. ensure you're not reusing a Serialiser between requests\");\n      }\n\n      this.destroyed = true;\n      return this.data;\n    }\n  }, {\n    key: \"outputHydrationData\",\n    value: function outputHydrationData() {\n      return xEngine.render(xEngine.h(HydrationData, {\n        serialiser: this\n      }));\n    }\n  }]);\n\n  return Serialiser;\n}();\n\nvar Interaction = typeof window !== 'undefined' ? InteractionClass : InteractionSSR;\n\nvar invoke = function invoke(fnOrObj) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  return typeof fnOrObj === 'function' ? fnOrObj.apply(void 0, args) : fnOrObj;\n};\n\nvar withActions = function withActions(getActions) {\n  var getDefaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return function (Component) {\n    var _wraps = {\n      getActions: getActions,\n      getDefaultState: getDefaultState,\n      Component: Component\n    }; // if the component we're wrapping is already wrapped, we don't want\n    // to wrap it further. so, discard its wrapper and rewrap the original\n    // component with the new actions on top\n\n    if (Component._wraps) {\n      var wrappedGetActions = Component._wraps.getActions;\n      var wrappedGetDefaultState = Component._wraps.getDefaultState;\n      Component = Component._wraps.Component;\n\n      getActions = function getActions(initialState) {\n        return Object.assign(invoke(wrappedGetActions, initialState), invoke(_wraps.getActions, initialState));\n      };\n\n      getDefaultState = function getDefaultState(initialState) {\n        return Object.assign(invoke(wrappedGetDefaultState, initialState), invoke(_wraps.getDefaultState, initialState));\n      };\n    }\n\n    function Enhanced(_ref) {\n      var id = _ref.id,\n          actionsRef = _ref.actionsRef,\n          serialiser = _ref.serialiser,\n          initialState = _objectWithoutProperties(_ref, [\"id\", \"actionsRef\", \"serialiser\"]);\n\n      var actions = invoke(getActions, initialState);\n      var defaultState = invoke(getDefaultState, initialState);\n      return xEngine.h(Interaction, {\n        id: id,\n        Component: Component,\n        initialState: Object.assign({}, defaultState, initialState),\n        actionsRef: actionsRef,\n        serialiser: serialiser,\n        actions: actions\n      });\n    } // store what we're wrapping for later wrappers to replace\n\n\n    Enhanced._wraps = _wraps; // set the displayName of the Enhanced component for debugging\n\n    wrapComponentName(Component, Enhanced); // register the component under its name for later hydration from serialised data\n\n    registerComponent(Enhanced);\n    return Enhanced;\n  };\n};\n\nexports.withActions = withActions;\nexports.hydrate = hydrate;\nexports.HydrationData = HydrationData;\nexports.Serialiser = Serialiser;\n"],"mappings":"AAEA","sourceRoot":""}